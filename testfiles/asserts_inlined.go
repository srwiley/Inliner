// This file is generated by inliner. DO NOT EDIT.
// Source file: asserts.go
package main

import (
	"errors"
	//"fmt"
	"strconv"
)

// The expected sum is 100 after all the breaks and continues
func runAssertFlowTest() (sum int) {
	var numStr []string
	sum = 5
loop:
	for i := 0; i < 16; i++ {
		/* deny_(i == 10, "continue") /* inlined assert */
		if i == 10 {
			continue
		} /* */
		numStr = append(numStr, strconv.Itoa(i))
		/* affirm_(numStr) /* inlined assert */
		if numStr == nil {
			return
		} /* */
		/* deny_(i == 14, "break loop") /* inlined assert */
		if i == 14 {
			break loop
		} /* */
	}
	//fmt.Println("len nums ", len(numStr))
	/* affirm_(len(numStr) == 14) /* inlined assert */
	if (len(numStr) == 14) == false {
		return
	} /* */
	for _, s := range numStr {
		n, err := strconv.Atoi(s)
		/* deny_(err, "break") /* inlined assert */
		if err != nil {
			break
		} /* */
		/* affirm_(n >= 0) /* inlined assert */
		if (n >= 0) == false {
			return
		} /* */
		sum += n
	}
	return
}

// An error is returned it either number string is not parsable as an int
// or n1 >= n2 or n1 <= 0
func runAssertNumTest(numStr1, numStr2 string) (rerr error) {
	number, err := strconv.Atoi(numStr1)
	/* deny_(err, `return err`) /* inlined assert */
	if err != nil {
		return err
	} /* */ // Return if err is not nil
	errNgt := errors.New("number not gt 0")
	/* affirm_(number > 0, `return errNgt`) /* inlined assert */
	if (number > 0) == false {
		return errNgt
	} /* */ // Return if number is not gt zero
	number2, err2 := strconv.Atoi(numStr2)
	/* deny_(err2, `return err2`) /* inlined assert */
	if err2 != nil {
		return err2
	} /* */ // Return if err is not nil
	errNum := errors.New("number2 greater than number") // Return if number2 > number
	/* affirm_(number2 > number, `return errNum`) /* inlined assert */
	if (number2 > number) == false {
		return errNum
	} /* */
	/* deny_(err2, `rerr = err2; return`) /* inlined assert */
	if err2 != nil {
		rerr = err2
		return
	} /* */
	return
}
